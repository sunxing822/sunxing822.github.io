<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="java," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="JAVA中线程池的管理可以有效的避免线程太多耗尽机器资源,有效的管理控制线程。提高资源的利用率.Java中的线程池构造工具类Executors,具体的接口如下：123456789101112131415161718//创建一个固定长度的线程池，当线程池满的时候，线程池的规模将不再变化public static ExecutorService newFixedThreadPool(int nThre">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发编程学习(八) 线程池深入理解">
<meta property="og:url" content="http://www.sunxing.cc/2017/02/28/java-thread-study008/index.html">
<meta property="og:site_name" content="孙星的个人博客~">
<meta property="og:description" content="JAVA中线程池的管理可以有效的避免线程太多耗尽机器资源,有效的管理控制线程。提高资源的利用率.Java中的线程池构造工具类Executors,具体的接口如下：123456789101112131415161718//创建一个固定长度的线程池，当线程池满的时候，线程池的规模将不再变化public static ExecutorService newFixedThreadPool(int nThre">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.sunxing.cc/2017/02/28/java-thread-study008/images/thread/thread-single.png">
<meta property="og:image" content="http://www.sunxing.cc/2017/02/28/java-thread-study008/images/thread/thread-threadpoolexecutor.png">
<meta property="og:image" content="http://www.sunxing.cc/2017/02/28/java-thread-study008/images/thread/thread-pool-func.png">
<meta property="og:updated_time" content="2017-04-30T03:58:25.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java并发编程学习(八) 线程池深入理解">
<meta name="twitter:description" content="JAVA中线程池的管理可以有效的避免线程太多耗尽机器资源,有效的管理控制线程。提高资源的利用率.Java中的线程池构造工具类Executors,具体的接口如下：123456789101112131415161718//创建一个固定长度的线程池，当线程池满的时候，线程池的规模将不再变化public static ExecutorService newFixedThreadPool(int nThre">
<meta name="twitter:image" content="http://www.sunxing.cc/2017/02/28/java-thread-study008/images/thread/thread-single.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>
 <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1258995301'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1258995301' type='text/javascript'%3E%3C/script%3E"));</script>

  <title> java并发编程学习(八) 线程池深入理解 | 孙星的个人博客~ </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">孙星的个人博客~</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">搬砖的,码农~</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                java并发编程学习(八) 线程池深入理解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-02-28T15:22:46+08:00" content="2017-02-28">
              2017-02-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/02/28/java-thread-study008/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/28/java-thread-study008/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>JAVA中线程池的管理可以有效的避免线程太多耗尽机器资源,有效的管理控制线程。提高资源的利用率.Java中的线程池构造工具类Executors,具体的接口如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//创建一个固定长度的线程池，当线程池满的时候，线程池的规模将不再变化</div><div class="line">public static ExecutorService newFixedThreadPool(int nThreads)</div><div class="line"></div><div class="line">//这两个方法用于创建ForkJoin框架中用到的ForkJoinPool线程池，第一个函数中的参数用于指定并行数，第二个函数没有参数，它默认使用当前机器可用的CPU个数作为并行数。</div><div class="line">public static ExecutorService newWorkStealingPool()</div><div class="line">public static ExecutorService newWorkStealingPool(int parallelism)</div><div class="line"></div><div class="line">//创建一个单线程的Executor，串行执行</div><div class="line">public static ExecutorService newSingleThreadExecutor()</div><div class="line"></div><div class="line">//创建一个可缓存的线程池，如果当前线程池的规模超出了处理需求，将回收空的线程；当需求增加时，会增加线程数量；线程池规模无限制。</div><div class="line">public static ExecutorService newCachedThreadPool()</div><div class="line"></div><div class="line">//创建单个线程的线程池，而且以延迟或者定时的方式来执行，类似Timer；</div><div class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor()</div><div class="line"></div><div class="line">//创建一个固定长度的线程池，而且以延迟或者定时的方式来执行，类似Timer；</div><div class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</div></pre></td></tr></table></figure></p>
<h3 id="1-newFixedThreadPool"><a href="#1-newFixedThreadPool" class="headerlink" title="1 newFixedThreadPool"></a>1 newFixedThreadPool</h3><p>newFixedThreadPool创建一个固定长度的线程池，当线程池满的时候，线程池的规模将不再变化,该方法的参数一共有两种情况,具体的如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newFixedThreadPool(int nThreads)</div><div class="line">public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)</div></pre></td></tr></table></figure></p>
<p>这两个函数用于创建一个最大线程数目固定的线程池，该线程池用一个共享的无界队列来存储提交的任务。参数nThreads指定线程池的最大线程数，参数threadFactory是线程工厂类，主要用于自定义线程池中创建新线程时的行为。<br>需要说明的是，创建线程池时，如果线程池没有接收到任何任务，则线程池中不会创建新线程，在线程池中线程数目少于最大线程数时，每来一个新任务就创建一个新线程，当线程数达到最大线程数时，不再创建新线程，新来的任务存储在队列中，之后线程数目不再变化！</p>
<p>使用实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public void start()&#123;</div><div class="line">       //构造一个线程池</div><div class="line">       ExecutorService service = Executors.newFixedThreadPool(10);</div><div class="line">       service.execute(new Runnable() &#123;</div><div class="line">           @Override</div><div class="line">           public void run() &#123;</div><div class="line">               while(true)&#123;</div><div class="line">                   System.out.println(System.currentTimeMillis());</div><div class="line">                   try&#123;</div><div class="line">                       Thread.sleep(1000);</div><div class="line">                   &#125;catch (Exception e)&#123;</div><div class="line">                       e.printStackTrace();</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">    service.shutdown();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>通过第二个接口来实现线程池的构建:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//构造一个线程池</div><div class="line">ExecutorService service = Executors.newFixedThreadPool(10,new DefaultThreadFactory());</div><div class="line"></div><div class="line">//线程构造工厂</div><div class="line">public class DefaultThreadFactory implements ThreadFactory&#123;</div><div class="line">    @Override</div><div class="line">    public Thread newThread(Runnable r) &#123;</div><div class="line">        final Thread t = new Thread(r, &quot;defalut-thread&quot;);</div><div class="line">        return t;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>jdk中底层代码如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</div><div class="line">        return new ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                      0L, TimeUnit.MILLISECONDS,</div><div class="line">                                      new LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-newSingleThreadExecutor"><a href="#2-newSingleThreadExecutor" class="headerlink" title="2 newSingleThreadExecutor"></a>2 newSingleThreadExecutor</h3><p>newSingleThreadExecutor:单例线程，任意时间池中只能有一个线程.用的是和cache池和fixed池相同的底层池，但线程数目是1-1,0秒IDLE（无IDLE）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newSingleThreadExecutor() &#123;</div><div class="line">        return new FinalizableDelegatedExecutorService</div><div class="line">            (new ThreadPoolExecutor(1, 1,</div><div class="line">                                    0L, TimeUnit.MILLISECONDS,</div><div class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>具体的使用和Fixed池相同,它能保证线程的先后顺序执行，并且能保证一条线程执行完成后才开启另一条新的线程。</p>
<p>具体的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public void start()&#123;</div><div class="line">       //构造一个线程池</div><div class="line">       ExecutorService service = Executors.newSingleThreadExecutor();</div><div class="line">       for(int i=0;i&lt;3;i++)&#123;</div><div class="line">           service.execute(new Runnable() &#123;</div><div class="line">               private int index = 0;</div><div class="line">               @Override</div><div class="line">               public void run() &#123;</div><div class="line">                   System.out.println(&quot; --------------------线程开始------------------- &quot;);</div><div class="line">                   while(true)&#123;</div><div class="line">                       System.out.println(&quot; -&gt; &quot; + System.currentTimeMillis());</div><div class="line">                       try&#123;</div><div class="line">                           index ++;</div><div class="line">                           if(index &gt; 5)break;</div><div class="line">                           Thread.sleep(1000);</div><div class="line">                       &#125;catch (Exception e)&#123;</div><div class="line">                           e.printStackTrace();</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;);</div><div class="line">       &#125;</div><div class="line">       service.shutdown();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>由上面的代码可以看出来,应该是先打印出5个时间戳，启动第二个线程,在打印5个时间戳，在启动第三个线程，打印5个时间戳。具体的结果如下：</p>
<p><img src="images/thread/thread-single.png" alt=""></p>
<h3 id="3-newCachedThreadPool"><a href="#3-newCachedThreadPool" class="headerlink" title="3 newCachedThreadPool"></a>3 newCachedThreadPool</h3><p>CachedThreadPool首先会按照需要创建足够多的线程来执行任务(Task)。随着程序执行的过程，有的线程执行完了任务，可以被重新循环使用时，才不再创建新的线程来执行任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newCachedThreadPool() &#123;</div><div class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</div><div class="line">                                      60L, TimeUnit.SECONDS,</div><div class="line">                                      new SynchronousQueue&lt;Runnable&gt;());</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>由此可以看到其实newFixedThreadPool,newSingleThreadExecutor，newCachedThreadPool通过这三个方法来构造的线程池都是相同的底层池(ThreadPoolExecutor)，该底层线程池的具体实现在下面在做赘述。</p>
<p>下面开始使用newCachedThreadPool使用实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public void start()&#123;</div><div class="line">        //构造一个线程池</div><div class="line">        ExecutorService service = Executors.newCachedThreadPool();</div><div class="line">        for(int i=0;i&lt;3;i++)&#123;</div><div class="line">            service.execute(new Runnable() &#123;</div><div class="line">                private int index = 0;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    System.out.println(&quot; --------------------线程开始------------------- &quot;);</div><div class="line">                    while(true)&#123;</div><div class="line">                        System.out.println(&quot; -&gt; &quot; + System.currentTimeMillis());</div><div class="line">                        try&#123;</div><div class="line">                            index ++;</div><div class="line">                            if(index &gt; 5)break;</div><div class="line">                            Thread.sleep(1000);</div><div class="line">                        &#125;catch (Exception e)&#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        service.shutdown();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>其实可以看的出来其实用发基本没有什么不同，可能针对的应用场景不同。cache池是同时构造足够的线程来执行任务，所以一开始并行执行的，所以执行的结果和通过newSingleThreadExecutor构造出来的线程执行的结果肯定不相同的~</p>
<h3 id="4-newScheduledThreadPool"><a href="#4-newScheduledThreadPool" class="headerlink" title="4 newScheduledThreadPool"></a>4 newScheduledThreadPool</h3><p>它能设置线程执行的先后间隔及执行时间等，功能比上面的三个强大了一些。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public void start()&#123;</div><div class="line">        //构造一个线程池</div><div class="line">        ScheduledExecutorService service = Executors.newScheduledThreadPool(3);</div><div class="line">        for(int i=0;i&lt;3;i++)&#123;</div><div class="line">            service.schedule(new Runnable() &#123;</div><div class="line">                private int index = 0;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    System.out.println(&quot; --------------------线程开始------------------- &quot;);</div><div class="line">                    while(true)&#123;</div><div class="line">                        System.out.println(&quot; -&gt; &quot; + new Date());</div><div class="line">                        try&#123;</div><div class="line">                            index ++;</div><div class="line">                            if(index &gt; 3)break;</div><div class="line">                            Thread.sleep(1000);</div><div class="line">                        &#125;catch (Exception e)&#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;,3,TimeUnit.SECONDS); //延迟3秒执行</div><div class="line">        &#125;</div><div class="line">        service.shutdown();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>ScheduledExecutorService是任务调度,可以通过指定频率周期执行谋个任务,或则是指定频率间隔执行谋个任务.具体的接口如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//指定频率周期执行谋个任务</div><div class="line">public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</div><div class="line">                                                  long initialDelay,</div><div class="line">                                                  long period,</div><div class="line">                                                  TimeUnit unit);</div></pre></td></tr></table></figure></p>
<p>间隔指的是连续两次任务开始执行的间隔。对于scheduleAtFixedRate方法，当执行任务的时间大于我们指定的间隔时间时，它并不会在指定间隔时开辟一个新的线程并发执行这个任务。而是等待该线程执行完毕。也就是每隔period执行一次，注意，如果上次的线程还没有执行完成，那么会阻塞下一个线程的执行。即使线程池设置得足够大</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//指定执行频率间隔执行谋个任务</div><div class="line">public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</div><div class="line">                                                     long initialDelay,</div><div class="line">                                                     long delay,</div><div class="line">                                                     TimeUnit unit);</div></pre></td></tr></table></figure>
<p>间隔指的是连续上次执行完成和下次开始执行之间的间隔。</p>
<h3 id="5-newSingleThreadScheduledExecutor"><a href="#5-newSingleThreadScheduledExecutor" class="headerlink" title="5 newSingleThreadScheduledExecutor"></a>5 newSingleThreadScheduledExecutor</h3><p>其实这个方法构造线程池是构造单个线程线程池，对应的线程池接口为：ScheduledExecutorService。所以对应的接口和newScheduledThreadPool构造的相对应的线程池相同.</p>
<h3 id="6-newWorkStealingPool"><a href="#6-newWorkStealingPool" class="headerlink" title="6 newWorkStealingPool"></a>6 newWorkStealingPool</h3><p>创建一个拥有多个任务队列（以便减少连接数）的 ExecutorService。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newWorkStealingPool(int parallelism)</div><div class="line">public static ExecutorService newWorkStealingPool()</div></pre></td></tr></table></figure>
<p>这两个方法用于创建ForkJoin框架中用到的ForkJoinPool线程池，第一个函数中的参数用于指定并行数，第二个函数没有参数，它默认使用当前机器可用的CPU个数作为并行数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public void start1() throws InterruptedException &#123;</div><div class="line">        ExecutorService executor = Executors.newWorkStealingPool();</div><div class="line"></div><div class="line">        List&lt;Callable&lt;String&gt;&gt; callables = Arrays.asList(</div><div class="line">                () -&gt; &quot;task1&quot;,</div><div class="line">                () -&gt; &quot;task2&quot;,</div><div class="line">                () -&gt; &quot;task3&quot;);</div><div class="line"></div><div class="line">        executor.invokeAll(callables)</div><div class="line">                .stream()</div><div class="line">                .map(future -&gt; &#123;</div><div class="line">                    try &#123;</div><div class="line">                        return future.get();</div><div class="line">                    &#125;</div><div class="line">                    catch (Exception e) &#123;</div><div class="line">                        throw new IllegalStateException(e);</div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">                .forEach(System.out::println);</div><div class="line"></div><div class="line">        executor.shutdown();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void start2()&#123;</div><div class="line">        ExecutorService service = Executors.newWorkStealingPool();</div><div class="line">        for(int i=0;i&lt;3;i++)&#123;</div><div class="line">            service.execute(() -&gt; System.out.println(System.currentTimeMillis()));</div><div class="line">        &#125;</div><div class="line">        service.shutdown();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>ThreadPoolExecutor是jdk底层实现的一个线程池操作，通过上面的几种方式(newFixedThreadPool,newCachedThreadPool,newSingleThreadExecutor)都是通过构造一个ThreadPoolExecutor来实现的，只是参数不同.ThreadPoolExecutor的主要的类继承关系如下:(图片在网上找的)<br><img src="images/thread/thread-threadpoolexecutor.png" alt=""></p>
<p>下面来看下ThreadPoolExecutor的具体的代码常量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">private static final int COUNT_BITS = Integer.SIZE - 3;</div><div class="line"></div><div class="line">// 运行状态标志位</div><div class="line">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;//</div><div class="line">private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</div><div class="line">private static final int STOP       =  1 &lt;&lt; COUNT_BITS;</div><div class="line">private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;</div><div class="line">private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</div><div class="line"></div><div class="line">//线程缓冲队列，当线程池线程运行超过一定线程时并满足一定的条件，待运行的线程会放入到这个队列  </div><div class="line">private final BlockingQueue&lt;Runnable&gt; workQueue;</div><div class="line">//重入锁，更新核心线程池大小、最大线程池大小时要加锁</div><div class="line">private final ReentrantLock mainLock = new ReentrantLock();</div><div class="line">//所有的工作线程,都会被加入到这个集合中</div><div class="line">private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();</div><div class="line">//重入锁状态</div><div class="line">private final Condition termination = mainLock.newCondition();</div><div class="line">//用来记录线程池中曾经出现过的最大线程数</div><div class="line">private int largestPoolSize;</div><div class="line">//完成的任务数</div><div class="line">private long completedTaskCount;</div><div class="line">//线程构建工厂</div><div class="line">private volatile ThreadFactory threadFactory;</div><div class="line">//当缓冲队列也放不下线程时的拒绝策略</div><div class="line">private volatile RejectedExecutionHandler handler;</div><div class="line">//线程执行完成后在线程池中的缓存时间</div><div class="line">private volatile long keepAliveTime;</div><div class="line">//如果为false,核心线程空闲时一样会存活，如果为true,则线程空闲后，超过allowCoreThreadTimeOut的时间没有进行工作以后就会死亡</div><div class="line">private volatile boolean allowCoreThreadTimeOut;</div><div class="line">//核心线程数</div><div class="line">private volatile int corePoolSize;</div><div class="line">//最大的线程池容量大小</div><div class="line">private volatile int maximumPoolSize;</div><div class="line">//默认的拒绝策略</div><div class="line">private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();</div></pre></td></tr></table></figure></p>
<p>上面介绍了ThreadPoolExecutor中具体的一些常量，以及这些常量的具体意义，那么使用ThreadPoolExecutor如何进行构建一个线程池:<br><img src="images/thread/thread-pool-func.png" alt=""></p>
<p>通过查看源代码可以知道,最终调用的构造函数为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public ThreadPoolExecutor(int corePoolSize,</div><div class="line">                              int maximumPoolSize,</div><div class="line">                              long keepAliveTime,</div><div class="line">                              TimeUnit unit,</div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                              ThreadFactory threadFactory,</div><div class="line">                              RejectedExecutionHandler handler) &#123;</div><div class="line">        if (corePoolSize &lt; 0 ||</div><div class="line">            maximumPoolSize &lt;= 0 ||</div><div class="line">            maximumPoolSize &lt; corePoolSize ||</div><div class="line">            keepAliveTime &lt; 0)</div><div class="line">            throw new IllegalArgumentException();</div><div class="line">        if (workQueue == null || threadFactory == null || handler == null)</div><div class="line">            throw new NullPointerException();</div><div class="line">        this.corePoolSize = corePoolSize;</div><div class="line">        this.maximumPoolSize = maximumPoolSize;</div><div class="line">        this.workQueue = workQueue;</div><div class="line">        this.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">        this.threadFactory = threadFactory;</div><div class="line">        this.handler = handler;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>通过上面介绍常量的说明可以看出来,其实构造函数是初始化一些参数(核心线程数,最大线程数,工作队列等等)。由此可以有如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public void start()&#123;</div><div class="line">        int corePoolSize = 1;</div><div class="line">        int maximumPoolSize = 1;</div><div class="line">        long keepAliveTime = 1;</div><div class="line">        TimeUnit unit = TimeUnit.SECONDS;</div><div class="line">        BlockingQueue&lt;Runnable&gt; workQueue = new ArrayBlockingQueue&lt;&gt;(2);</div><div class="line">        ThreadFactory threadFactory = new DefaultThreadFactory();</div><div class="line">        RejectedExecutionHandler handler = new DefaultRejectedExecutionHandler();</div><div class="line"></div><div class="line">        ThreadPoolExecutor pool = new ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime,unit,workQueue,threadFactory,handler);</div><div class="line">        for(int i=0;i&lt;3;i++)&#123;</div><div class="line">            pool.execute(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    while(true)&#123;</div><div class="line">                        System.out.println(System.currentTimeMillis());</div><div class="line">                        try&#123;</div><div class="line">                            Thread.sleep(100);</div><div class="line">                        &#125;catch (Exception e)&#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>其实和ExecutorService的用发相同,因为ExecutorService底层使用的也是ThreadPoolService,因此提交线程也是使用executor和submit.那么我提交一个线程到线程池中具体是如何作业的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public void execute(Runnable command) &#123;</div><div class="line">    if (command == null)</div><div class="line">        throw new NullPointerException();</div><div class="line">    /*</div><div class="line">     * Proceed in 3 steps:</div><div class="line">     *</div><div class="line">     * 1. If fewer than corePoolSize threads are running, try to</div><div class="line">     * start a new thread with the given command as its first</div><div class="line">     * task.  The call to addWorker atomically checks runState and</div><div class="line">     * workerCount, and so prevents false alarms that would add</div><div class="line">     * threads when it shouldn&apos;t, by returning false.</div><div class="line">     *</div><div class="line">     * 2. If a task can be successfully queued, then we still need</div><div class="line">     * to double-check whether we should have added a thread</div><div class="line">     * (because existing ones died since last checking) or that</div><div class="line">     * the pool shut down since entry into this method. So we</div><div class="line">     * recheck state and if necessary roll back the enqueuing if</div><div class="line">     * stopped, or start a new thread if there are none.</div><div class="line">     *</div><div class="line">     * 3. If we cannot queue task, then we try to add a new</div><div class="line">     * thread.  If it fails, we know we are shut down or saturated</div><div class="line">     * and so reject the task.</div><div class="line">     */</div><div class="line">    int c = ctl.get();</div><div class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">        if (addWorker(command, true))</div><div class="line">            return;</div><div class="line">        c = ctl.get();</div><div class="line">    &#125;</div><div class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">        int recheck = ctl.get();</div><div class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">            reject(command);</div><div class="line">        else if (workerCountOf(recheck) == 0)</div><div class="line">            addWorker(null, false);</div><div class="line">    &#125;</div><div class="line">    else if (!addWorker(command, false))</div><div class="line">        reject(command);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>1 如果当前工作线程数小于核心线程数,则将当前线程加入到工作队列中</p>
<pre><code>if (workerCountOf(c) &lt; corePoolSize)
</code></pre><p>2 如果正在运行并且当前工作线程队列中没有满，则还需要二次判定(具体的看下上面的英文注释)检测当前线程池是否关闭</p>
<p>3 如果直接添加线程到队列中，如果添加失败,表示线程已经满了，直接拒绝线程添加。</p>
<p>其实上面三个部分都是通过不同的条件来判定如何操作。其中主要的方法还是addWorker()方法，那么添加一个Runnable构造的线程后是如何做到自动执行run方法的呢？</p>
<p>addWorkder的源码内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</div><div class="line">        retry:</div><div class="line">        for (;;) &#123;</div><div class="line">            int c = ctl.get();</div><div class="line">            int rs = runStateOf(c);</div><div class="line"></div><div class="line">            // Check if queue empty only if necessary.</div><div class="line">            if (rs &gt;= SHUTDOWN &amp;&amp;</div><div class="line">                ! (rs == SHUTDOWN &amp;&amp;</div><div class="line">                   firstTask == null &amp;&amp;</div><div class="line">                   ! workQueue.isEmpty()))</div><div class="line">                return false;</div><div class="line"></div><div class="line">            for (;;) &#123;</div><div class="line">                int wc = workerCountOf(c);</div><div class="line">                if (wc &gt;= CAPACITY ||</div><div class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</div><div class="line">                    return false;</div><div class="line">                if (compareAndIncrementWorkerCount(c))</div><div class="line">                    break retry;</div><div class="line">                c = ctl.get();  // Re-read ctl</div><div class="line">                if (runStateOf(c) != rs)</div><div class="line">                    continue retry;</div><div class="line">                // else CAS failed due to workerCount change; retry inner loop</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        boolean workerStarted = false;</div><div class="line">        boolean workerAdded = false;</div><div class="line">        Worker w = null;</div><div class="line">        try &#123;</div><div class="line">            w = new Worker(firstTask);</div><div class="line">            final Thread t = w.thread;</div><div class="line">            if (t != null) &#123;</div><div class="line">                final ReentrantLock mainLock = this.mainLock;</div><div class="line">                mainLock.lock();</div><div class="line">                try &#123;</div><div class="line">                    // Recheck while holding lock.</div><div class="line">                    // Back out on ThreadFactory failure or if</div><div class="line">                    // shut down before lock acquired.</div><div class="line">                    int rs = runStateOf(ctl.get());</div><div class="line"></div><div class="line">                    if (rs &lt; SHUTDOWN ||</div><div class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</div><div class="line">                        if (t.isAlive()) // precheck that t is startable</div><div class="line">                            throw new IllegalThreadStateException();</div><div class="line">                        workers.add(w);</div><div class="line">                        int s = workers.size();</div><div class="line">                        if (s &gt; largestPoolSize)</div><div class="line">                            largestPoolSize = s;</div><div class="line">                        workerAdded = true;</div><div class="line">                    &#125;</div><div class="line">                &#125; finally &#123;</div><div class="line">                    mainLock.unlock();</div><div class="line">                &#125;</div><div class="line">                if (workerAdded) &#123;</div><div class="line">                    t.start();</div><div class="line">                    workerStarted = true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (! workerStarted)</div><div class="line">                addWorkerFailed(w);</div><div class="line">        &#125;</div><div class="line">        return workerStarted;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>其实上面的核心代码是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">w = new Worker(firstTask);</div><div class="line">final Thread t = w.thread;</div></pre></td></tr></table></figure></p>
<p>构造一个Worker对象,同时将该对象加入到任务队列中,如果添加成功,则执行t.start();由此可以看出其实就是在这里进行调用启动线程的。那么Worker具体是什么内容呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">private final class Worker</div><div class="line">        extends AbstractQueuedSynchronizer</div><div class="line">        implements Runnable</div><div class="line">    &#123;</div><div class="line">        /**</div><div class="line">         * This class will never be serialized, but we provide a</div><div class="line">         * serialVersionUID to suppress a javac warning.</div><div class="line">         */</div><div class="line">        private static final long serialVersionUID = 6138294804551838833L;</div><div class="line"></div><div class="line">        /** Thread this worker is running in.  Null if factory fails. */</div><div class="line">        final Thread thread;</div><div class="line">        /** Initial task to run.  Possibly null. */</div><div class="line">        Runnable firstTask;</div><div class="line">        /** Per-thread task counter */</div><div class="line">        volatile long completedTasks;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * Creates with given first task and thread from ThreadFactory.</div><div class="line">         * @param firstTask the first task (null if none)</div><div class="line">         */</div><div class="line">        Worker(Runnable firstTask) &#123;</div><div class="line">            setState(-1); // inhibit interrupts until runWorker</div><div class="line">            this.firstTask = firstTask;</div><div class="line">            this.thread = getThreadFactory().newThread(this);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /** Delegates main run loop to outer runWorker  */</div><div class="line">        public void run() &#123;</div><div class="line">            runWorker(this);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Lock methods</div><div class="line">        //</div><div class="line">        // The value 0 represents the unlocked state.</div><div class="line">        // The value 1 represents the locked state.</div><div class="line"></div><div class="line">        ...........</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可见，其中Worker是通过构造函数给自己的两个成员变量赋值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">this.firstTask = firstTask;</div><div class="line">this.thread = getThreadFactory().newThread(this);</div></pre></td></tr></table></figure></p>
<p>由这里可以看得出来,是通过ThreadFactory来构造了一个新的线程,同样的通过上面的addWorker方法中的介绍可以看出，其实运行的也就是ThreadFactory构造出来的这个线程,启动的是Worker这个Runnable的子类,也就是其实运行的Worker的run方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void run() &#123;</div><div class="line">    runWorker(this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看得出来,这个是执行runWorker(),那么总的过程是：addWorker(Runnable r,boolean flag)这个方法中通过构造一个Worker,以及给这个Worker绑定一个新构造出来的Thread,这个Thread是通过Worker对象构造出来的，Thread在addWorkder中会执行start()方法，因此<br>会在执行的时候调用Worker的run方法(因为Worker继承Runnable,该Thread是通过Worker构造出来的),而Worker的run方法只是调用了另外一个方法runWorker.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">final void runWorker(Worker w) &#123;</div><div class="line">        Thread wt = Thread.currentThread();</div><div class="line">        Runnable task = w.firstTask;</div><div class="line">        w.firstTask = null;</div><div class="line">        w.unlock(); // allow interrupts</div><div class="line">        boolean completedAbruptly = true;</div><div class="line">        try &#123;</div><div class="line">            while (task != null || (task = getTask()) != null) &#123;</div><div class="line">                w.lock();</div><div class="line">                // If pool is stopping, ensure thread is interrupted;</div><div class="line">                // if not, ensure thread is not interrupted.  This</div><div class="line">                // requires a recheck in second case to deal with</div><div class="line">                // shutdownNow race while clearing interrupt</div><div class="line">                if ((runStateAtLeast(ctl.get(), STOP) ||</div><div class="line">                     (Thread.interrupted() &amp;&amp;</div><div class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class="line">                    !wt.isInterrupted())</div><div class="line">                    wt.interrupt();</div><div class="line">                try &#123;</div><div class="line">                    beforeExecute(wt, task);</div><div class="line">                    Throwable thrown = null;</div><div class="line">                    try &#123;</div><div class="line">                        task.run();</div><div class="line">                    &#125; catch (RuntimeException x) &#123;</div><div class="line">                        thrown = x; throw x;</div><div class="line">                    &#125; catch (Error x) &#123;</div><div class="line">                        thrown = x; throw x;</div><div class="line">                    &#125; catch (Throwable x) &#123;</div><div class="line">                        thrown = x; throw new Error(x);</div><div class="line">                    &#125; finally &#123;</div><div class="line">                        afterExecute(task, thrown);</div><div class="line">                    &#125;</div><div class="line">                &#125; finally &#123;</div><div class="line">                    task = null;</div><div class="line">                    w.completedTasks++;</div><div class="line">                    w.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            completedAbruptly = false;</div><div class="line">        &#125; finally &#123;</div><div class="line">            processWorkerExit(w, completedAbruptly);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可见其实如果构造Woker的时候指定的Runnable为null的话,会调用getTask重新赋值,赋值以后在进行调用run方法，执行线程(这里直接调用run方法,有点不解….下面在继续说…).那么可以看出构造线程池的方式有多种了：</p>
<p>1 通过execute来执行线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ExecutorService service = Executors.newSingleThreadExecutor();</div><div class="line">        service.execute(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                while(true)&#123;</div><div class="line">                    try&#123;</div><div class="line">                        System.out.println(System.currentTimeMillis());</div><div class="line">                        Thread.sleep(1000);</div><div class="line">                    &#125;catch (Exception e)&#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>2 通过submit来执行线程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ExecutorService service = Executors.newSingleThreadExecutor();</div><div class="line">        Future&lt;?&gt; future = service.submit(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                System.out.println(System.currentTimeMillis());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        System.out.println(future.isDone());</div><div class="line">        System.out.println(future.get(2,TimeUnit.SECONDS));</div><div class="line">        System.out.println(future.isDone());</div></pre></td></tr></table></figure></p>
<p>其中submit是有返回值的，但是在这个地方如果submit提交的是集成Runnable接口的子类实现类,那么返回的结果为null(future.get()),具体的可以看到底层源码的注释说明:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * Submits a Runnable task for execution and returns a Future</div><div class="line">    * representing that task. The Future&apos;s &#123;@code get&#125; method will</div><div class="line">    * return &#123;@code null&#125; upon &lt;em&gt;successful&lt;/em&gt; completion.</div><div class="line">    *</div><div class="line">    * @param task the task to submit</div><div class="line">    * @return a Future representing pending completion of the task</div><div class="line">    * @throws RejectedExecutionException if the task cannot be</div><div class="line">    *         scheduled for execution</div><div class="line">    * @throws NullPointerException if the task is null</div><div class="line">    */</div><div class="line">   Future&lt;?&gt; submit(Runnable task);</div></pre></td></tr></table></figure></p>
<p>3 通过往workQueue队列中添加Runnable<br>其实通过上面的源码介绍可以看到,其实ThreadPoolExcutor是将任务添加到一个队列中,用于管理当前运行的任务。那么我给想队列中添加线程对象即可或者是给定一个线程队列集合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">int corePoolSize = 3;</div><div class="line">      int maximumPoolSize = 10;</div><div class="line">      long keepAliveTime = 1;</div><div class="line">      TimeUnit unit = TimeUnit.SECONDS;</div><div class="line">      BlockingQueue&lt;Runnable&gt; workQueue = new LinkedBlockingQueue&lt;&gt;();</div><div class="line">      RejectedExecutionHandler handler = new DefaultRejectedExecutionHandler();</div><div class="line"></div><div class="line">      workQueue.offer(new Runnable() &#123;</div><div class="line">          @Override</div><div class="line">          public void run() &#123;</div><div class="line">              System.out.println(System.currentTimeMillis());</div><div class="line">          &#125;</div><div class="line">      &#125;);</div><div class="line"></div><div class="line">      ThreadPoolExecutor pool = new ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime,</div><div class="line">              unit,workQueue,Executors.defaultThreadFactory(),handler);</div><div class="line"></div><div class="line">      int i = pool.prestartAllCoreThreads();</div><div class="line">      System.out.println(i);</div></pre></td></tr></table></figure></p>
<p>其实就是想队列中添加数据,然后启动所有的线程,那么后台会从队列中读取一个线程进行调用start方法~</p>
<p>4 通过重构Runnable来启动构造线程<br>在构造线程池的时候，会指定ThreadFactorty，那么这个类是用来干嘛的呢，是用来构造线程对象的，默认的ThreadFactory的内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">static class DefaultThreadFactory implements ThreadFactory &#123;</div><div class="line">        private static final AtomicInteger poolNumber = new AtomicInteger(1);</div><div class="line">        private final ThreadGroup group;</div><div class="line">        private final AtomicInteger threadNumber = new AtomicInteger(1);</div><div class="line">        private final String namePrefix;</div><div class="line"></div><div class="line">        DefaultThreadFactory() &#123;</div><div class="line">            SecurityManager s = System.getSecurityManager();</div><div class="line">            group = (s != null) ? s.getThreadGroup() :</div><div class="line">                                  Thread.currentThread().getThreadGroup();</div><div class="line">            namePrefix = &quot;pool-&quot; +</div><div class="line">                          poolNumber.getAndIncrement() +</div><div class="line">                         &quot;-thread-&quot;;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public Thread newThread(Runnable r) &#123;</div><div class="line">            Thread t = new Thread(group, r,</div><div class="line">                                  namePrefix + threadNumber.getAndIncrement(),</div><div class="line">                                  0);</div><div class="line">            if (t.isDaemon())</div><div class="line">                t.setDaemon(false);</div><div class="line">            if (t.getPriority() != Thread.NORM_PRIORITY)</div><div class="line">                t.setPriority(Thread.NORM_PRIORITY);</div><div class="line">            return t;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>默认的ThreadFactory只是根据给定的一个Runnable子类接口的实现类来重新构造一个Thread类。那么如果我重新构造是不是就可以实现指定线程池的大小直接进行线程的自动构造并运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int corePoolSize = 3;</div><div class="line">      int maximumPoolSize = 10;</div><div class="line">      long keepAliveTime = 1;</div><div class="line">      TimeUnit unit = TimeUnit.SECONDS;</div><div class="line">      BlockingQueue&lt;Runnable&gt; workQueue = new LinkedBlockingQueue&lt;&gt;();</div><div class="line">      ThreadFactory threadFactory = new DefaultThreadFactory();</div><div class="line">      RejectedExecutionHandler handler = new DefaultRejectedExecutionHandler();</div><div class="line"></div><div class="line">      ThreadPoolExecutor pool = new ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime,</div><div class="line">              unit,workQueue,threadFactory,handler);</div><div class="line"></div><div class="line">      int i = pool.prestartAllCoreThreads();</div><div class="line">      System.out.println(i);</div></pre></td></tr></table></figure></p>
<p>其中DefaultThreadFactory为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class DefaultThreadFactory implements ThreadFactory&#123;</div><div class="line">        @Override</div><div class="line">        public Thread newThread(Runnable r) &#123;</div><div class="line">            return new Thread(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    while (true) &#123;</div><div class="line">                        System.out.println(Thread.currentThread().getName() + &quot; -&gt; &quot; + System.currentTimeMillis());</div><div class="line">                        try &#123;</div><div class="line">                            Thread.sleep(1000);</div><div class="line">                        &#125; catch (Exception e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>丢弃掉给定的Runnable接口,重新构建的接口对象,其实在调用过程中newThread的参数是一个Worker对象,如果一开始任务队列为空，那么调用newThread的参数Worker对象成员变量firstTask为null.Worker的成员变量thread对应的则为通过newThread构造出来的对象。</p>
<h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><p>自定义线程池主要是由于根据ThreadPoolExcutor来进行封装。ThreadPoolExcutor的构造函数如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public ThreadPoolExecutor(int corePoolSize,</div><div class="line">                              int maximumPoolSize,</div><div class="line">                              long keepAliveTime,</div><div class="line">                              TimeUnit unit,</div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                              ThreadFactory threadFactory,</div><div class="line">                              RejectedExecutionHandler handler)</div></pre></td></tr></table></figure></p>
<p>具体的例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line">public class LinkedBlockQueueThreadPool extends ThreadPoolExecutor &#123;</div><div class="line">    protected Logger log = LoggerFactory.getLogger(getClass());</div><div class="line">    /**</div><div class="line">     * 正在执行任务数量</div><div class="line">     */</div><div class="line">    private AtomicInteger taskNum = new AtomicInteger(0);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 构建线程池</div><div class="line">     * @param corePoolSize    池中所保存的核心线程数</div><div class="line">     * @param maximumPoolSize    池中允许的最大线程数</div><div class="line">     * @param keepActiveTime    非核心线程空闲等待新任务的最长时间</div><div class="line">     * @param timeunit    keepActiveTime参数的时间单位</div><div class="line">     * @param blockingqueue    任务队列</div><div class="line">     */</div><div class="line">    public LinkedBlockQueueThreadPool(int corePoolSize, int maximumPoolSize, long keepActiveTime, TimeUnit timeunit,</div><div class="line">                              BlockingQueue&lt;Runnable&gt; blockingqueue) &#123;</div><div class="line">        super(corePoolSize, maximumPoolSize, keepActiveTime, timeunit, blockingqueue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 构建线程池</div><div class="line">     * @param corePoolSize    池中所保存的核心线程数</div><div class="line">     * @param maximumPoolSize    池中允许的最大线程数</div><div class="line">     * @param keepActiveTime    非核心线程空闲等待新任务的最长时间(单位：秒)</div><div class="line">     * @param blockingqueue    任务队列</div><div class="line">     */</div><div class="line">    public LinkedBlockQueueThreadPool(int corePoolSize, int maximumPoolSize, long keepActiveTime,</div><div class="line">                              BlockingQueue&lt;Runnable&gt; blockingqueue) &#123;</div><div class="line">        this(corePoolSize, maximumPoolSize, keepActiveTime, TimeUnit.SECONDS, blockingqueue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 构建线程池</div><div class="line">     * @param corePoolSize    池中所保存的核心线程数</div><div class="line">     * @param maximumPoolSize    池中允许的最大线程数</div><div class="line">     * @param keepActiveTime    非核心线程空闲等待新任务的最长时间(单位：秒)</div><div class="line">     */</div><div class="line">    public LinkedBlockQueueThreadPool(int corePoolSize, int maximumPoolSize, long keepActiveTime) &#123;</div><div class="line">        this(corePoolSize, maximumPoolSize, keepActiveTime, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 构建单线程的线程池</div><div class="line">     */</div><div class="line">    public LinkedBlockQueueThreadPool() &#123;</div><div class="line">        this(1, 1, 1, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 任务执行，以原子方式将当前值加 1</div><div class="line">     */</div><div class="line">    public void execute(Runnable task) &#123;</div><div class="line">        taskNum.getAndIncrement();</div><div class="line">        super.execute(task);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 任务执行之后</div><div class="line">     */</div><div class="line">    public void afterExecute(Runnable task, Throwable throwable) &#123;</div><div class="line">        taskNum.decrementAndGet();</div><div class="line">        log.debug(&quot;task : &quot; + task.getClass().getSimpleName()</div><div class="line">                +  &quot; completed,Throwable:&quot; + throwable + &quot;,taskNum:&quot; + getTaskNum());</div><div class="line">        synchronized(this) &#123;</div><div class="line">            notifyAll();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 挂起当前线程，直到所有任务执行完成</div><div class="line">     */</div><div class="line">    public void waitComplete() &#123;</div><div class="line">        try &#123;</div><div class="line">            synchronized(this)&#123;</div><div class="line">                while(getTaskNum() &gt; 0)&#123;</div><div class="line">                    wait(500);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            log.error(e + &quot;, taskNum:&quot; + getTaskNum());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @return    未执行的任务数</div><div class="line">     */</div><div class="line">    public int getTaskNum() &#123;</div><div class="line">        return taskNum.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param time    非核心线程空闲等待新任务的最长时间(单位：秒)</div><div class="line">     */</div><div class="line">    public void setKeepAliveTime(int time) &#123;</div><div class="line">        super.setKeepAliveTime(time, TimeUnit.SECONDS);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param size    池中所保存的核心线程数</div><div class="line">     */</div><div class="line">    public void setCorePoolSize(int size) &#123;</div><div class="line">        super.setCorePoolSize(size);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param size    池中允许的最大线程数</div><div class="line">     */</div><div class="line">    public void setMaximumPoolSize(int size) &#123;</div><div class="line">        super.setMaximumPoolSize(size);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag">#java</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/28/java-thread-study007/" rel="next" title="java并发编程学习(七) Thread中常用方法说明">
                <i class="fa fa-chevron-left"></i> java并发编程学习(七) Thread中常用方法说明
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/02/28/jiagou-study001/" rel="prev" title="数据离线统计架构设计">
                数据离线统计架构设计 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
           <!-- 多说热评文章 start -->
	<div class="ds-top-threads" data-range="daily" data-num-items="5"></div>
<!-- 多说热评文章 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"sunxing"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->


           <section id="comments">
   <!-- 多说评论框 start -->
<div id="ds-thread" class="ds-thread" data-thread-key="<%= post.path %>" data-title="<%= post.title %>" data-url="<%= post.permalink %>"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"sunxing"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->
  </section>

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="孙星" />
          <p class="site-author-name" itemprop="name">孙星</p>
          <p class="site-description motion-element" itemprop="description">sunxing's blog | mysql | java | scala | hadoop | spark | kafka | flume</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">65</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-newFixedThreadPool"><span class="nav-number">1.</span> <span class="nav-text">1 newFixedThreadPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-newSingleThreadExecutor"><span class="nav-number">2.</span> <span class="nav-text">2 newSingleThreadExecutor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-newCachedThreadPool"><span class="nav-number">3.</span> <span class="nav-text">3 newCachedThreadPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-newScheduledThreadPool"><span class="nav-number">4.</span> <span class="nav-text">4 newScheduledThreadPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-newSingleThreadScheduledExecutor"><span class="nav-number">5.</span> <span class="nav-text">5 newSingleThreadScheduledExecutor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-newWorkStealingPool"><span class="nav-number">6.</span> <span class="nav-text">6 newWorkStealingPool</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-number"></span> <span class="nav-text">ThreadPoolExecutor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义线程池"><span class="nav-number"></span> <span class="nav-text">自定义线程池</span></a></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">孙星</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"sunxing"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
